<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>채팅창 & Typing 애니메이션 예제</title>
  <!-- lottie-web 라이브러리 CDN (bodymovin) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js"></script>
  <!-- Mathpix Markdown-it CDN (LaTeX 렌더링) -->
  <script src="https://cdn.jsdelivr.net/npm/mathpix-markdown-it@2.0.6/es5/bundle.js"></script>
  <style>
    html, body {
       overflow-x: hidden; /* 좌우 스크롤 제거 */
    }
    body {
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Arial, sans-serif;
    }
    /* Safe Area를 고려한 컨테이너 (전체 너비 사용) */
    #chat-container {
      width: 100%;
      margin: 0 auto;
      padding-top: calc(env(safe-area-inset-top, 0px) + 10px);
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      padding-left: calc(env(safe-area-inset-left, 0px) + 10px);
      padding-right: calc(env(safe-area-inset-right, 0px) + 10px);
      box-sizing: border-box;
      height: calc(100vh - 80px);
      overflow: hidden;
    }
    /* 메시지 목록 영역 */
    #messages {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 100%;
      overflow-y: auto;
      overflow-x: hidden; /* 좌우 스크롤 제거 */
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 0px);
      border-bottom: 0px solid #eee;
    }
    /* 메시지 컨테이너 (헤더, 버블, 타임스탬프를 포함) */
    .message {
      margin-bottom: 4px;
      position: relative;
    }
    /* sent / received 정렬 */
    .sent {
      align-self: flex-end;
    }
    .received {
      align-self: flex-start;
      text-align: left;
    }
    /* 실제 메시지 내용을 담는 버블 (배경 적용) */
    .chat-bubble {
      padding: 8px 12px;
      display: inline-flex;
      max-width: 95%;
    }
    .sent .chat-bubble {
      background-color: #dcf8c6;
      text-align: left;

      /* 모서리 설정: 오른쪽 하단은 0, 나머지는 4px */
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 0;      
    }
    .received .chat-bubble {
      background-color: #fff;
      
      /* 모서리 설정: 왼쪽 하단은 0, 나머지는 4px */
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      border-bottom-right-radius: 8px;
      border-bottom-left-radius: 0;
    }
    .sent .chat-timestamp {
      text-align: right !important;
    }
    /* 시스템 메시지 상단 헤더 (아이콘 + 시스템명), 배경 투명, 상단에 표시 */
    .chat-header {
      display: block;       /* block-level 요소로 만들어 한 줄 전체를 차지 */
      text-align: left;   /* 내부 콘텐츠(아이콘과 시스템명)를 중앙 정렬 */
      white-space: nowrap;  /* 불필요한 줄바꿈 제거 */
      margin-bottom: 4px;
      background: transparent;
    }
    .ai-icon {
      width: 14px;
      height: 14px;
      vertical-align: middle;
      color: #666;
    }
    .system-name {
      font-size: 0.8em;
      vertical-align: middle;
      margin-left: 4px;
      color: #666;
    }
    /* 메시지 하단 타임스탬프, 배경 투명 */
    .chat-timestamp {
      font-size: 0.8em;
      color: #666;
      margin-top: 4px;
      background: transparent;
    }
    /* 타이핑 애니메이션 영역 (기본 숨김) */
    #lottie-container {
      width: 64px;
      height: 40px;
      display: none;  /* 필요할 때만 보임 */
      margin: 0 0 0 10px;
    }
    /* 입력창 영역 */
    #input-area {
      display: flex;
      gap: 10px;
    }
    #message-input {
      flex: 1;
      padding: 6px 8px;
    }
    #send-button {
      padding: 6px 12px;
    }
  </style>
</head>
<body>
  <div id="chat-container">
    <!-- 메시지 목록 -->
    <div id="messages"></div>
    <!-- 타이핑 애니메이션을 위한 컨테이너 -->
    <div id="lottie-container"></div>
    <!-- 메시지 입력창 -->
    <div id="input-area">
      <input type="text" id="message-input" placeholder="메시지를 입력하세요">
      <button id="send-button">보내기</button>
    </div>
  </div>
  
  <script>
    // lottie-web을 이용하여 typing.json 애니메이션 로드
    var typingAnimation = lottie.loadAnimation({
      container: document.getElementById('lottie-container'),
      renderer: 'svg',
      loop: true,
      autoplay: true,
      path: 'typing.json'
    });
    
    // 메시지 추가 후 스크롤을 가장 아래로 이동시키는 함수
    function scrollToBottom() {
      var messagesDiv = document.getElementById("messages");
      if (messagesDiv) {
        messagesDiv.scrollTop = messagesDiv.scrollHeight - messagesDiv.clientHeight;
      }
    }
    
    /**
     * 타이핑 애니메이션 메시지 추가 함수 (header와 타임스탬프 없이 오직 애니메이션만 표시)
     */
     function showTypingIndicatorInMessage() {
      var messagesContainer = document.getElementById("messages");
      var typingMessage = document.createElement("div");
      typingMessage.classList.add("message", "received");
      
      // header와 타임스탬프 없이, 단지 채팅 버블 내에 lottie-container만 포함
      var bubble = document.createElement("div");
      bubble.className = "chat-bubble";
      bubble.style.backgroundColor = "transparent"; // 배경을 투명으로 설정

      // 기존 lottie-container 요소를 이동시킵니다.
      var lottieEl = document.getElementById("lottie-container");
      lottieEl.style.display = "block";      
      bubble.appendChild(lottieEl);
      
      typingMessage.appendChild(bubble);
      messagesContainer.appendChild(typingMessage);
      scrollToBottom();
    }
    
    /**
     * 타이핑 애니메이션 메시지를 제거하고 lottie-container를 원래 위치로 복원하는 함수
     */
    function hideTypingIndicatorInMessage() {
      var messagesContainer = document.getElementById("messages");
      var lastMessage = messagesContainer.lastElementChild;
      if (lastMessage && lastMessage.querySelector("#lottie-container")) {
        messagesContainer.removeChild(lastMessage);
        // 새 lottie-container 요소를 생성하여 chat-container에 추가합니다.
        var newLottie = document.createElement("div");
        newLottie.id = "lottie-container";
        newLottie.style.width = "64px";
        newLottie.style.height = "40px";
        newLottie.style.display = "none";
        newLottie.style.margin = "0 0 0 10px";
        document.getElementById("chat-container").appendChild(newLottie);
        lottie.loadAnimation({
          container: newLottie,
          renderer: 'svg',
          loop: true,
          autoplay: true,
          path: 'typing.json'
        });
      }
    }

    // 공통: received 메시지용 상단 헤더 생성 함수
    function createHeader() {
      var headerDiv = document.createElement("div");
      headerDiv.className = "chat-header";
      
      var aiIcon = document.createElement("img");
      aiIcon.src = "ai_icon_24.svg"; // 실제 경로로 변경
      aiIcon.alt = "AI Icon";
      aiIcon.className = "ai-icon";
      
      var systemName = document.createElement("span");
      systemName.className = "system-name";
      systemName.textContent = "다풀어";
      
      headerDiv.appendChild(aiIcon);
      headerDiv.appendChild(systemName);
      return headerDiv;
    }
    
    // 공통: 타임스탬프 생성 함수 ("YYYY-MM-DD HH:MM" 형식)
    function createTimestamp() {
      var timestampDiv = document.createElement("div");
      timestampDiv.className = "chat-timestamp";
      var now = new Date();
      var year = now.getFullYear();
      var month = now.getMonth() + 1;
      if (month < 10) { month = "0" + month; }
      var day = now.getDate();
      if (day < 10) { day = "0" + day; }
      var hours = now.getHours();
      if (hours < 10) { hours = "0" + hours; }
      var minutes = now.getMinutes();
      if (minutes < 10) { minutes = "0" + minutes; }
      timestampDiv.textContent = year + "-" + month + "-" + day + " " + hours + ":" + minutes;
      return timestampDiv;
    }

    /**
     * addMessage(text, type)
     * - text: 메시지 내용 (Markdown 및 LaTeX 포함 가능)
     * - type: "sent" 또는 "received"
     *
     * received 메시지 상단에는 아이콘과 시스템명을, 모든 메시지 하단에는 날짜와 시간을 표시합니다.
     * Mathpix Markdown-it(window.render)가 존재하면 렌더링합니다.
     * 헤더와 타임스탬프는 채팅 버블과 분리되어 배경이 투명하게 처리됩니다.
     */
    function addMessage(text, type) {
      var messagesContainer = document.getElementById("messages");
      var messageDiv = document.createElement("div");
      messageDiv.classList.add("message");
      messageDiv.classList.add(type);  // "sent" 또는 "received"
      
      // received 메시지인 경우 상단에 헤더(아이콘 + 시스템명) 추가
      if (type === "received") {
        hideTypingIndicatorInMessage();
        messageDiv.appendChild(createHeader());
      }
      
      // 실제 메시지 내용을 담는 버블 추가
      var bubble = document.createElement("div");
      bubble.className = "chat-bubble";
      messageDiv.appendChild(bubble);
      
      // 타임스탬프 생성 및 추가
      messageDiv.appendChild(createTimestamp());
      
      // 메시지 컨테이너에 추가 후 스크롤 이동
      messagesContainer.appendChild(messageDiv);
      scrollToBottom();
      
      // 메시지 내용 렌더링 (Markdown / LaTeX 처리)
      if (window.render && typeof window.render === 'function') {
        var options = { htmlTags: true };
        const trimText = text.replace(/(\\\[)([\s\S]*?)(\\\])/g, function(match, open, content, close) {
          return open + content.replace(/<br>/g, " ") + close;
        });
        
        if (typeof window.loadMathJax === "function") {
          console.log("Loading MathJax...");
          try {
            window.loadMathJax();
            setTimeout(function() {
              console.log("MathJax Loaded. Rendering...");
              bubble.innerHTML = window.render(trimText, options);
              scrollToBottom();
            }, 10);
          } catch (e) {
            console.log("Error load MathJax => " + e);
            bubble.innerHTML = trimText;
            scrollToBottom();
          }
        } else {
          console.log("MathJax Not Found. Rendering Directly...");
          bubble.innerHTML = window.render(trimText, options);
          scrollToBottom();
        }
      } else {
        bubble.innerText = text;
        scrollToBottom();
      }
      
      // sent 메시지인 경우 타이핑 애니메이션과 자동응답 처리
      if (type === "sent") {
        showTypingIndicatorInMessage();
        // setTimeout(function() {
        //   hideTypingIndicatorInMessage();
        //   addMessage("자동응답: " + text, "received");
        // }, 500);
      }
    }
    
    /**
     * 이미지 메시지 추가 함수
     * @param {string} imageData - 이미지의 URL 또는 Data URL
     * @param {string} type - "sent" 또는 "received"
     */
    function addImageMessage(imageData, type) {
      var messagesContainer = document.getElementById("messages");
      var messageDiv = document.createElement("div");
      messageDiv.classList.add("message");
      messageDiv.classList.add(type);
      
      // received 메시지의 경우 헤더 추가
      if (type === "received") {
        hideTypingIndicatorInMessage();
        messageDiv.appendChild(createHeader());
      }
      
      // 이미지 메시지 내용을 담는 버블
      var bubble = document.createElement("div");
      bubble.className = "chat-bubble";
      var img = document.createElement("img");
      img.src = imageData;
      img.style.maxWidth = "90%";
      img.style.borderRadius = "10px";
      bubble.appendChild(img);
      messageDiv.appendChild(bubble);
      
      // 타임스탬프 생성 및 추가
      messageDiv.appendChild(createTimestamp());
      
      messagesContainer.appendChild(messageDiv);
      scrollToBottom();

      if (type === "sent") {
        showTypingIndicatorInMessage();
      }      
    }

    /**
     * 스트리밍 응답 업데이트용 함수 (렌더링 포함)
     * 
     * 이 함수는 채팅 메시지 목록의 마지막 "received" 메시지 요소를 찾아,
     * 그 내부의 메시지 버블을 업데이트합니다.
     * 만약 window.render 함수가 존재한다면, Markdown 및 LaTeX 렌더링을 수행하여
     * 업데이트된 메시지를 출력합니다.
     * 
     * 동작:
     * 1. 'messages' 컨테이너에서 마지막 메시지 요소를 찾습니다.
     * 2. 해당 요소가 "received" 타입인지 확인한 후, 내부의 .chat-bubble 요소를 선택합니다.
     * 3. window.render가 존재하면 렌더링 옵션을 적용해 새 텍스트를 렌더링하고,
     *    MathJax를 사용하는 경우 MathJax 로딩 후 렌더링합니다.
     * 4. 렌더링 결과를 버블의 innerHTML에 적용한 후 스크롤을 업데이트합니다.
     * 
     * @param {string} newText - 업데이트할 메시지 텍스트 (HTML 형식 지원)
     */
    function updateLastMessage(newText) {
      var messagesContainer = document.getElementById("messages");
      var lastMessage = messagesContainer.lastElementChild;
      if (lastMessage && lastMessage.classList.contains("received")) {
        var bubble = lastMessage.querySelector(".chat-bubble");
        if (bubble) {
          // 메시지 내용 렌더링 (Markdown / LaTeX 처리)
          if (window.render && typeof window.render === 'function') {
            var options = { htmlTags: true };
            // addMessage()와 유사하게 텍스트를 전처리 (예시)
            const trimText = newText.replace(/(\\\[)([\s\S]*?)(\\\])/g, function(match, open, content, close) {
              return open + content.replace(/<br>/g, " ") + close;
            });
            
            if (typeof window.loadMathJax === "function") {
              console.log("Loading MathJax for updateLastMessage...");
              try {
                window.loadMathJax();
                setTimeout(function() {
                  console.log("MathJax Loaded for updateLastMessage. Rendering...");
                  bubble.innerHTML = window.render(trimText, options);
                  scrollToBottom();
                }, 10);
              } catch (e) {
                console.log("Error loading MathJax in updateLastMessage: " + e);
                bubble.innerHTML = trimText;
                scrollToBottom();
              }
            } else {
              console.log("MathJax Not Found in updateLastMessage. Rendering Directly...");
              bubble.innerHTML = window.render(trimText, options);
              scrollToBottom();
            }
          } else {
            // 렌더러가 없는 경우 일반 텍스트로 설정
            bubble.innerHTML = newText;
            scrollToBottom();
          }
        }
      }
    }

    // "보내기" 버튼 클릭 시 동작
    document.getElementById('send-button').addEventListener('click', function() {
      var input = document.getElementById('message-input');
      var text = input.value.trim();
      if (text !== "") {
        // URL 형식과 이미지 확장자 (.png, .jpg, .jpeg, .gif 등)를 확인
        var imageUrlPattern = /^(http[s]?:\/\/.*\.(?:png|jpg|jpeg|gif))(?:\?.*)?$/i;
        if (imageUrlPattern.test(text)) {
          // 이미지 URL이면 addImageMessage() 호출하여 메시지에 이미지를 표시
          addImageMessage(text, "sent");
        } else {
          // 그 외의 경우는 기존 addMessage()로 텍스트 메시지를 처리
          addMessage(text, "sent");
        }
        input.value = "";
      }
    });
    
    // 엔터키 입력 시 "보내기" 버튼과 동일하게 작동
    document.getElementById('message-input').addEventListener('keyup', function(e) {
      if (e.key === 'Enter') {
        document.getElementById('send-button').click();
      }
    });
  </script>
</body>
</html>
