<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <!-- 뷰포트 설정: env(safe-area-inset-*) 사용을 위해 viewport-fit=cover 필요 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Chat UI (Messages Only)</title>
  <style>
    html, body {
       overflow-x: hidden; /* 좌우 스크롤 제거 */
    }
    body {
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Helvetica, Arial, sans-serif;
    }
    /* Safe Area를 고려한 컨테이너 */
    .chat-container {
      padding-top: calc(env(safe-area-inset-top, 0px) + 10px);
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      box-sizing: border-box;
      height: 100vh;
      overflow: hidden;
    }
    /* 메시지 영역에 추가 여백을 줘서 마지막 메시지가 입력 영역 위에 나타나도록 함 */
    .chat-messages {
      padding: 10px;
      /* 기존 여백 10px + 추가 여백(예: 100px, 입력 영역 높이에 맞춰 조정) */
      padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px) + 50px);
      overflow-y: auto;
      overflow-x: hidden; /* 좌우 스크롤 제거 */
      height: 100%;
      box-sizing: border-box;
    }
    .chat-message {
      margin: 5px 0;
    }
    .chat-bubble {
      display: inline-block;
      padding: 10px;
      border-radius: 10px;
      max-width: 90%;
      word-wrap: break-word;
      word-break: break-all;       /* 긴 단어도 줄바꿈 */
      background: #ddd;
      font-size: 14px;
      text-align: left; /* 👈 왼쪽 정렬 강제 적용 */
    }
    .chat-message.sent {
      text-align: right;
    }
    .chat-message.sent .chat-bubble {
      background: #0084FF; /* 보낸 메시지는 파란색 */
      color: white;
      text-align: left; /* 👈 내부 텍스트는 왼쪽 정렬 유지 */
      display: inline-block;
    }
      
    /* 수신 메시지 (왼쪽 정렬, 밝은 회색 배경) */
    .chat-message.received {
      text-align: left;
    }
    .chat-message.received .chat-bubble {
      background: #e5e5ea;
      color: black;
      text-align: left;
    }
  </style>
  <!-- mathpix-markdown-it 라이브러리 로드 (수식 및 Markdown 렌더링) -->
  <script src="https://cdn.jsdelivr.net/npm/mathpix-markdown-it@2.0.6/es5/bundle.js"></script>
  <!-- lottie-web 라이브러리 로드 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
  <script>
      (function() {
        // console.log 출력을 Swift로 전달
        var oldLog = console.log;
        console.log = function(message) {
          oldLog.apply(console, arguments);
          if (window.webkit && window.webkit.messageHandlers.consoleLog) {
            window.webkit.messageHandlers.consoleLog.postMessage(message);
          }
        };
        console.log("JavaScript Loaded Successfully.");
      })();
      
      var typingAnimation; // 전역 변수에 할당해서 제어할 수 있음
      // DOMContentLoaded 이후에 Lottie 애니메이션을 로드
      document.addEventListener("DOMContentLoaded", function() {
        typingAnimation = lottie.loadAnimation({
          container: document.getElementById('lottie-animation'), // 애니메이션이 표시될 컨테이너
          renderer: 'svg',      // svg 렌더러 사용
          loop: true,           // 무한 반복
          autoplay: true,       // 자동 재생
          path: 'typing.json'   // typing.json 파일 경로 (대소문자 및 경로 확인)
        });
        
        typingAnimation.play()
        console.log("typingAnimation....."+typingAnimation);
      });
      
      // 타이핑 애니메이션을 보이게 하는 함수
      function showTypingAnimation() {
        console.log("showTypingAnimation.....");
        var container = document.getElementById("lottie-animation");
        if (container) {
          console.log("container....."+container);
          console.log("typingAnimation....."+typingAnimation);

          container.style.display = "block";
          if (typingAnimation) {
            typingAnimation.play();
            
            console.log("showTypingAnimation...play()");
          }
        }
      }

      // 타이핑 애니메이션을 숨기는 함수
      function hideTypingAnimation() {
        console.log("hideTypingAnimation.....");
        var container = document.getElementById("lottie-animation");
        if (container) {
          container.style.display = "none";
          if (typingAnimation) {
            typingAnimation.stop();
          }
        }
      }
      
      function addMessage(text, type) {
        var container = document.getElementById("chatMessages");
        var messageDiv = document.createElement("div");
        messageDiv.className = "chat-message " + type;
        
        var bubble = document.createElement("div");
        bubble.className = "chat-bubble";

        //console.log("Processing message: " + text);

        if (window.render && typeof window.render === 'function') {
          var options = { htmlTags: true };

          const trimText = text.replace(/(\\\[)([\s\S]*?)(\\\])/g, (match, open, content, close) => {
            // 캡쳐한 content 내의 개행문자를 공백으로 치환
            const newContent = content.replace(/<br>/g, " ");
            return open + newContent + close;
          });
          
          if (typeof window.loadMathJax === "function") {
            console.log("Loading MathJax...");
            try {
              window.loadMathJax();  // 직접 실행 후
              setTimeout(() => {  // 500ms 후 실행
                console.log("MathJax Loaded. Rendering...");
                bubble.innerHTML = window.render(trimText, options);
                showTypingAnimation()
                scrollToBottom();  // ✅ 스크롤 이동 추가
              }, 10);
            } catch (e) {
              console.log("Error load MathJax =>"+ e);
              bubble.innerHTML = trimText;
              scrollToBottom();  // ✅ 에러 발생 시에도 스크롤 이동
            }
          } else {
            console.log("MathJax Not Found. Rendering Directly...");
            bubble.innerHTML = window.render(trimText, options);
            scrollToBottom();  // ✅ 스크롤 이동 추가
          }
        } else {
          console.log("window.render not found. Using plain text.");
          bubble.innerText = trimText;
          scrollToBottom();  // ✅ 스크롤 이동 추가
        }

        messageDiv.appendChild(bubble);
        container.appendChild(messageDiv);
        
        // ✅ 비동기적으로 스크롤 이동
        setTimeout(scrollToBottom, 100);
      }

      // ✅ 정확한 스크롤 이동 함수 추가
    function scrollToBottom() {
        var container = document.getElementById("chatMessages");
        if (container) {
            container.scrollTop = container.scrollHeight - container.clientHeight;
        }
    }
      
    function addImageMessage(imageData, type) {
      var container = document.getElementById("chatMessages");
      var messageDiv = document.createElement("div");
      messageDiv.className = "chat-message " + type;
      
      var bubble = document.createElement("div");
      bubble.className = "chat-bubble";
      
      var img = document.createElement("img");
      img.src = imageData;
      img.style.maxWidth = "90%";
      img.style.borderRadius = "10px";
      
      bubble.appendChild(img);
      messageDiv.appendChild(bubble);
      container.appendChild(messageDiv);
      
      setTimeout(scrollToBottom, 100);
    }
  </script>
</head>
<body>
  <div class="chat-container">
    <div id="chatMessages" class="chat-messages"></div>
    <!-- Lottie 애니메이션이 표시될 영역 -->
    <div id="lottie-animation" class="lottie-container" style="width: 64px; height: 40px;"></div>
  </div>
</body>
</html>
